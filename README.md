# FlappyBird
####A new version of the game FlappyBird running on Verilog


<p align="center">
<a href="file.gif"><img src="file.gif" title="source: home" /></a>
</p>

###Introduction: 

The purpose of this lab was to create a version of the game Flappy Bird. The game consisted of a bird, which was simplified to a black square, that attempted to flap its way through a series of obstacle pipes. The horizontal distance between the pipes remained constant, but the vertical height of each pipe was randomly generated. The player earned a point for each pipe the bird flew through, represented by a pink dot on the bottom right of the screen. If the current score was greater than the highest score, the current score replaced the highest score on the seven segment display. When a bird crashed into a pipe or landed on the floor, the bird dropped to the ground, the game ended, and a reset button could be used to play again.

###Design Description:
We used the files provided as part of this VGA demo as the backbone of our project:
https://pumpingstationone.org/2013/04/nerp­fpgaok/
NERP_demo_top.v: T his was the top module for the game handling input and most game behavior. The game had three different states: when the bird crashed, when the game was reset, and when the bird was in flight. The first always block detected crashes, score kept, and controlled the current state of the bird. The second always block was used to create a clock that was implemented to generate the pipe coordinates and change them at a speed that the VGA
  
 displayed smoothly. The third always block, running at the posedge of the clock that was created in the second always block, incremented the horizontal coordinates of the pipes when the bird is in flight, regenerated random pipes whenever a pipe crossed the left­end of the screen, and reset the initial pipe’s location when the reset button was pressed. The randomness of the pipes came from using the module RNG.v, which will be discussed later in this report.
Vga640x480.v: T his module, the framework of which was from the online tutorial files given to us by the TA, was used to display the objects on the VGA. While we kept most of the mechanics, we used them to draw something considerably different. The inputs, which came from the NERP_demo_top.v module, gave the coordinates for the pipes, bird, and the current score. The bird had a constant horizontal assignment of 40 pixels right of the horizontal back porch. But the vertical assignment was dependent on the state of the bird. The pipes, which their positions were inputted from the NERP_demo_top.v module, had a constant width of 50 pixels and were always above the green patch of grass. Furthermore, in order to display our scores, we created a case statement to display in symbolic form the current number of points accrued.
RNG.v: T his module was used to randomly generate the y­coordinates of the pipes. This th 
module was implemented as a 21 bit linear­feedback shift register that XORed the 21 bit with th 
the 18 bit, shifted the stored value right by 1, and set the new leftmost bit to the XORed value at the positive edge of each clock cycle. Using sequential logic, we were able to reinitialize our “random” register and create our pseudo­random output. Because we let the RNG continuously run from the start and did not reset the register at any point, we ensured that the values taken from the register to be used as pillar height would differ between playthroughs.
bird.v: T his module was used to implement the physics of the bird. Our first always block was used to divide the input clk’s value in order to slow down the pace of the bird’s flight to one better suited to gameplay. The second always block was used to either increase or decrease the bird’s velocity depending on the bird state and the signal of the jump button. When the bird was in flight and the jump button was pressed, the bird’s velocity increased by a decimal value of 10. However, when the jump button was not pressed, the bird’s velocity decreased by 1 for every time unit, emulating a physically accurate fall with constant acceleration. Furthermore, if the bird was no longer in flight, we assigned the velocity to be 0, since the bird had crashed and the game had not restarted yet. The third always block was used to assign the y­coordinate of the bird based on its velocity. If the bird was in flight, we added the velocity’s value to its current y­coordinate value in order to either increment or decrement its y­coordinate position. When the bird had crashed, its y­coordinate was fixed to 0 to represent the fact that it had fallen to the ground. And when the game was reset, then the bird’s y­coordinate was reset to the starting y­coordinate position, which we determined to be 300.
c l o c k d i v . v : T h i s m o d u l e w a s g i v e n t o u s b y t h e T A . H o w e v e r , w e h a d t o m o d i f y t h i s m o d u l e i n order to create a 25MHz clock for the display with our faster chip clock, and to create a clock output with suitable frequency for the bird’s flight. Using an always block, the author of the code
created a 17­bit counter. Then using the 17 bit counter, we were able to create a 381.47 Hz and 25 Mhz clock for the bird and the VGA display respectively.
s e g d i s p l a y . v : T h i s m o d u l e w a s u s e d t o o u t p u t t h e h i g h e s t s c o r e a c h i e v e d s o f a r o n t h e seven­segment display in hexadecimal. The module cycled through the anodes of the display, lighting one digit up at a time. We used two case statements, one to convert the current score into its cathode representation, and one to synchronize the current anode with the correct lit cathodes to display the digit in that position.
